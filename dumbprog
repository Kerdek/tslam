# let combinator #

(\a.a a) (\x f.f x) \let.

# recursive combinator #
let (\f x.f $ x x) \dga.
let (\f.(dga f) (dga f)) \rec.

# self-evaluator #
let (rec \e.[
  \f x.f x e,
  \a b.a e $ b e,
  \a b.a e : b e,
  \a b.a e + b e,
  \a b.a e * b e,
  \x.`ope`,
  \x.'x,
  \x.x])
\eval.

# self-printer #
let (rec \e v.[
  \f.`(\\v${v}.${f `v${v}` (e (v + 1))})`,
  \a b.`(${a (e v)} ${b (e v)})`,
  \a b.`(${a (e v)} : ${b (e v)})`,
  \a b.`(${a (e v)} + ${b (e v)})`,
  \a b.`(${a (e v)} * ${b (e v)})`,
  \x.`(${"`"}${x (e v)})`,
  \x.`('${x (e v)})`,
  \x.`${x}`])
\print.

# query the kind of a node #
let [
  \f."uni",
  \a b."app",
  \a b."cns",
  \a b."add",
  \a b."mul",
  \x."itp",
  \x."qot",
  \x."lit"]
\kind.

# lib #
let (\a.a) \id.
let (\a b.a) \left.
let (\a b.b) \right.
let (let left) \car.
let (let right) \cdr.
let (\f g x.f $ g x) \compose.
let (\a b.compose (let a) b) \push.
let (\a b.push b $ push a $ id) \pair.
let (\c a b.c (left a) b) \if.
let (\a b c.if c a b) \cond.
let (pair (\a b x.right) id) \empty.
let (\x y.bind x $ left y) \do.

# do the ios in a list #
let (rec \f l.if (empty l) $ pass; do (car l) $ f $ cdr l) \doall.

# postfix and prefix zero check #
let (left []) \is-zero.
let (let is-zero) \zero.

# add and multiply aliases #
let (\a b.a + b) \add.
let (\a b.a * b) \mul.

# increment #
let (add 1) \inc.

let (\base cond op. rec \f x. if (cond x) base (op x $ x f)) \recurrence.
let (recurrence 0 zero add) \handshakes.
let (compose (recurrence 1 zero mul) inc) \factorial.

let 1 \n.

# the program #
doall [
  clear,
  putStr (('(\x z.z x) 7) (print 0))
]